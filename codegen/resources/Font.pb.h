// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: resources/Font.proto

#ifndef PROTOBUF_resources_2fFont_2eproto__INCLUDED
#define PROTOBUF_resources_2fFont_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)
namespace buffers {
namespace resources {
class Font;
class FontDefaultTypeInternal;
extern FontDefaultTypeInternal _Font_default_instance_;
class Font_Glyph;
class Font_GlyphDefaultTypeInternal;
extern Font_GlyphDefaultTypeInternal _Font_Glyph_default_instance_;
class Font_Range;
class Font_RangeDefaultTypeInternal;
extern Font_RangeDefaultTypeInternal _Font_Range_default_instance_;
}  // namespace resources
}  // namespace buffers

namespace buffers {
namespace resources {

namespace protobuf_resources_2fFont_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_resources_2fFont_2eproto

// ===================================================================

class Font_Glyph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font.Glyph) */ {
 public:
  Font_Glyph();
  virtual ~Font_Glyph();

  Font_Glyph(const Font_Glyph& from);

  inline Font_Glyph& operator=(const Font_Glyph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font_Glyph(Font_Glyph&& from) noexcept
    : Font_Glyph() {
    *this = ::std::move(from);
  }

  inline Font_Glyph& operator=(Font_Glyph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font_Glyph& default_instance();

  static inline const Font_Glyph* internal_default_instance() {
    return reinterpret_cast<const Font_Glyph*>(
               &_Font_Glyph_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Font_Glyph* other);
  friend void swap(Font_Glyph& a, Font_Glyph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font_Glyph* New() const PROTOBUF_FINAL { return New(NULL); }

  Font_Glyph* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font_Glyph& from);
  void MergeFrom(const Font_Glyph& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font_Glyph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 character = 1;
  bool has_character() const;
  void clear_character();
  static const int kCharacterFieldNumber = 1;
  ::google::protobuf::uint32 character() const;
  void set_character(::google::protobuf::uint32 value);

  // optional uint32 x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  ::google::protobuf::uint32 x() const;
  void set_x(::google::protobuf::uint32 value);

  // optional uint32 y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  ::google::protobuf::uint32 y() const;
  void set_y(::google::protobuf::uint32 value);

  // optional uint32 width = 4 [(.buffers.gmx) = "w"];
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 5 [(.buffers.gmx) = "h"];
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // optional int32 shift = 6;
  bool has_shift() const;
  void clear_shift();
  static const int kShiftFieldNumber = 6;
  ::google::protobuf::int32 shift() const;
  void set_shift(::google::protobuf::int32 value);

  // optional int32 offset = 7;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 7;
  ::google::protobuf::int32 offset() const;
  void set_offset(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font.Glyph)
 private:
  void set_has_character();
  void clear_has_character();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_shift();
  void clear_has_shift();
  void set_has_offset();
  void clear_has_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 character_;
  ::google::protobuf::uint32 x_;
  ::google::protobuf::uint32 y_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::int32 shift_;
  ::google::protobuf::int32 offset_;
  friend struct protobuf_resources_2fFont_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Font_Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font.Range) */ {
 public:
  Font_Range();
  virtual ~Font_Range();

  Font_Range(const Font_Range& from);

  inline Font_Range& operator=(const Font_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font_Range(Font_Range&& from) noexcept
    : Font_Range() {
    *this = ::std::move(from);
  }

  inline Font_Range& operator=(Font_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font_Range& default_instance();

  static inline const Font_Range* internal_default_instance() {
    return reinterpret_cast<const Font_Range*>(
               &_Font_Range_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Font_Range* other);
  friend void swap(Font_Range& a, Font_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font_Range* New() const PROTOBUF_FINAL { return New(NULL); }

  Font_Range* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font_Range& from);
  void MergeFrom(const Font_Range& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font_Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 min = 1 [(.buffers.gmx) = "GMX_SPLIT/0"];
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 1;
  ::google::protobuf::int32 min() const;
  void set_min(::google::protobuf::int32 value);

  // optional int32 max = 2 [(.buffers.gmx) = "GMX_SPLIT/1"];
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  ::google::protobuf::int32 max() const;
  void set_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font.Range)
 private:
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int32 max_;
  friend struct protobuf_resources_2fFont_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Font : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font) */ {
 public:
  Font();
  virtual ~Font();

  Font(const Font& from);

  inline Font& operator=(const Font& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font(Font&& from) noexcept
    : Font() {
    *this = ::std::move(from);
  }

  inline Font& operator=(Font&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font& default_instance();

  static inline const Font* internal_default_instance() {
    return reinterpret_cast<const Font*>(
               &_Font_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Font* other);
  friend void swap(Font& a, Font& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font* New() const PROTOBUF_FINAL { return New(NULL); }

  Font* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font& from);
  void MergeFrom(const Font& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Font_Glyph Glyph;
  typedef Font_Range Range;

  // accessors -------------------------------------------------------

  // repeated .buffers.resources.Font.Range ranges = 7 [(.buffers.gmx) = "ranges/range0"];
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 7;
  const ::buffers::resources::Font_Range& ranges(int index) const;
  ::buffers::resources::Font_Range* mutable_ranges(int index);
  ::buffers::resources::Font_Range* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >&
      ranges() const;

  // repeated .buffers.resources.Font.Glyph glyphs = 8 [(.buffers.gmx) = "glyphs/glyph"];
  int glyphs_size() const;
  void clear_glyphs();
  static const int kGlyphsFieldNumber = 8;
  const ::buffers::resources::Font_Glyph& glyphs(int index) const;
  ::buffers::resources::Font_Glyph* mutable_glyphs(int index);
  ::buffers::resources::Font_Glyph* add_glyphs();
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >*
      mutable_glyphs();
  const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >&
      glyphs() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string font_name = 3 [(.buffers.gmx) = "name"];
  bool has_font_name() const;
  void clear_font_name();
  static const int kFontNameFieldNumber = 3;
  const ::std::string& font_name() const;
  void set_font_name(const ::std::string& value);
  #if LANG_CXX11
  void set_font_name(::std::string&& value);
  #endif
  void set_font_name(const char* value);
  void set_font_name(const char* value, size_t size);
  ::std::string* mutable_font_name();
  ::std::string* release_font_name();
  void set_allocated_font_name(::std::string* font_name);

  // optional string ttf_file = 14 [(.buffers.gmx) = "TTFName"];
  bool has_ttf_file() const;
  void clear_ttf_file();
  static const int kTtfFileFieldNumber = 14;
  const ::std::string& ttf_file() const;
  void set_ttf_file(const ::std::string& value);
  #if LANG_CXX11
  void set_ttf_file(::std::string&& value);
  #endif
  void set_ttf_file(const char* value);
  void set_ttf_file(const char* value, size_t size);
  ::std::string* mutable_ttf_file();
  ::std::string* release_ttf_file();
  void set_allocated_ttf_file(::std::string* ttf_file);

  // optional string image = 16;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 16;
  const ::std::string& image() const;
  void set_image(const ::std::string& value);
  #if LANG_CXX11
  void set_image(::std::string&& value);
  #endif
  void set_image(const char* value);
  void set_image(const char* value, size_t size);
  ::std::string* mutable_image();
  ::std::string* release_image();
  void set_allocated_image(::std::string* image);

  // optional int32 id = 2 [(.buffers.gmx) = "GMX_DEPRECATED"];
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // optional bool bold = 5;
  bool has_bold() const;
  void clear_bold();
  static const int kBoldFieldNumber = 5;
  bool bold() const;
  void set_bold(bool value);

  // optional bool italic = 6;
  bool has_italic() const;
  void clear_italic();
  static const int kItalicFieldNumber = 6;
  bool italic() const;
  void set_italic(bool value);

  // optional bool renderhq = 10;
  bool has_renderhq() const;
  void clear_renderhq();
  static const int kRenderhqFieldNumber = 10;
  bool renderhq() const;
  void set_renderhq(bool value);

  // optional bool include_ttf = 13 [(.buffers.gmx) = "includeTTF"];
  bool has_include_ttf() const;
  void clear_include_ttf();
  static const int kIncludeTtfFieldNumber = 13;
  bool include_ttf() const;
  void set_include_ttf(bool value);

  // optional uint32 charset = 11;
  bool has_charset() const;
  void clear_charset();
  static const int kCharsetFieldNumber = 11;
  ::google::protobuf::uint32 charset() const;
  void set_charset(::google::protobuf::uint32 value);

  // optional uint32 aa = 12;
  bool has_aa() const;
  void clear_aa();
  static const int kAaFieldNumber = 12;
  ::google::protobuf::uint32 aa() const;
  void set_aa(::google::protobuf::uint32 value);

  // optional int32 texture_group = 15 [(.buffers.gmx) = "texgroups/texgroup0"];
  bool has_texture_group() const;
  void clear_texture_group();
  static const int kTextureGroupFieldNumber = 15;
  ::google::protobuf::int32 texture_group() const;
  void set_texture_group(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_font_name();
  void clear_has_font_name();
  void set_has_size();
  void clear_has_size();
  void set_has_bold();
  void clear_has_bold();
  void set_has_italic();
  void clear_has_italic();
  void set_has_renderhq();
  void clear_has_renderhq();
  void set_has_charset();
  void clear_has_charset();
  void set_has_aa();
  void clear_has_aa();
  void set_has_include_ttf();
  void clear_has_include_ttf();
  void set_has_ttf_file();
  void clear_has_ttf_file();
  void set_has_texture_group();
  void clear_has_texture_group();
  void set_has_image();
  void clear_has_image();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range > ranges_;
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph > glyphs_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr font_name_;
  ::google::protobuf::internal::ArenaStringPtr ttf_file_;
  ::google::protobuf::internal::ArenaStringPtr image_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 size_;
  bool bold_;
  bool italic_;
  bool renderhq_;
  bool include_ttf_;
  ::google::protobuf::uint32 charset_;
  ::google::protobuf::uint32 aa_;
  ::google::protobuf::int32 texture_group_;
  friend struct protobuf_resources_2fFont_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Font_Glyph

// optional uint32 character = 1;
inline bool Font_Glyph::has_character() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font_Glyph::set_has_character() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font_Glyph::clear_has_character() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font_Glyph::clear_character() {
  character_ = 0u;
  clear_has_character();
}
inline ::google::protobuf::uint32 Font_Glyph::character() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.character)
  return character_;
}
inline void Font_Glyph::set_character(::google::protobuf::uint32 value) {
  set_has_character();
  character_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.character)
}

// optional uint32 x = 2;
inline bool Font_Glyph::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font_Glyph::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font_Glyph::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font_Glyph::clear_x() {
  x_ = 0u;
  clear_has_x();
}
inline ::google::protobuf::uint32 Font_Glyph::x() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.x)
  return x_;
}
inline void Font_Glyph::set_x(::google::protobuf::uint32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.x)
}

// optional uint32 y = 3;
inline bool Font_Glyph::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Font_Glyph::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Font_Glyph::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Font_Glyph::clear_y() {
  y_ = 0u;
  clear_has_y();
}
inline ::google::protobuf::uint32 Font_Glyph::y() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.y)
  return y_;
}
inline void Font_Glyph::set_y(::google::protobuf::uint32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.y)
}

// optional uint32 width = 4 [(.buffers.gmx) = "w"];
inline bool Font_Glyph::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Font_Glyph::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Font_Glyph::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Font_Glyph::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 Font_Glyph::width() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.width)
  return width_;
}
inline void Font_Glyph::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.width)
}

// optional uint32 height = 5 [(.buffers.gmx) = "h"];
inline bool Font_Glyph::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Font_Glyph::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Font_Glyph::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Font_Glyph::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 Font_Glyph::height() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.height)
  return height_;
}
inline void Font_Glyph::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.height)
}

// optional int32 shift = 6;
inline bool Font_Glyph::has_shift() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Font_Glyph::set_has_shift() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Font_Glyph::clear_has_shift() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Font_Glyph::clear_shift() {
  shift_ = 0;
  clear_has_shift();
}
inline ::google::protobuf::int32 Font_Glyph::shift() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.shift)
  return shift_;
}
inline void Font_Glyph::set_shift(::google::protobuf::int32 value) {
  set_has_shift();
  shift_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.shift)
}

// optional int32 offset = 7;
inline bool Font_Glyph::has_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Font_Glyph::set_has_offset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Font_Glyph::clear_has_offset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Font_Glyph::clear_offset() {
  offset_ = 0;
  clear_has_offset();
}
inline ::google::protobuf::int32 Font_Glyph::offset() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.offset)
  return offset_;
}
inline void Font_Glyph::set_offset(::google::protobuf::int32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.offset)
}

// -------------------------------------------------------------------

// Font_Range

// optional int32 min = 1 [(.buffers.gmx) = "GMX_SPLIT/0"];
inline bool Font_Range::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font_Range::set_has_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font_Range::clear_has_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font_Range::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline ::google::protobuf::int32 Font_Range::min() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Range.min)
  return min_;
}
inline void Font_Range::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Range.min)
}

// optional int32 max = 2 [(.buffers.gmx) = "GMX_SPLIT/1"];
inline bool Font_Range::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font_Range::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font_Range::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font_Range::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 Font_Range::max() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Range.max)
  return max_;
}
inline void Font_Range::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Range.max)
}

// -------------------------------------------------------------------

// Font

// optional string name = 1;
inline bool Font::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Font::name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.name)
  return name_.GetNoArena();
}
inline void Font::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.name)
}
#if LANG_CXX11
inline void Font::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.name)
}
#endif
inline void Font::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.name)
}
inline void Font::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.name)
}
inline ::std::string* Font::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.name)
}

// optional int32 id = 2 [(.buffers.gmx) = "GMX_DEPRECATED"];
inline bool Font::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Font::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Font::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Font::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Font::id() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.id)
  return id_;
}
inline void Font::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.id)
}

// optional string font_name = 3 [(.buffers.gmx) = "name"];
inline bool Font::has_font_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font::set_has_font_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font::clear_font_name() {
  font_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_font_name();
}
inline const ::std::string& Font::font_name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.font_name)
  return font_name_.GetNoArena();
}
inline void Font::set_font_name(const ::std::string& value) {
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.font_name)
}
#if LANG_CXX11
inline void Font::set_font_name(::std::string&& value) {
  set_has_font_name();
  font_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.font_name)
}
#endif
inline void Font::set_font_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.font_name)
}
inline void Font::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.font_name)
}
inline ::std::string* Font::mutable_font_name() {
  set_has_font_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.font_name)
  return font_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_font_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.font_name)
  clear_has_font_name();
  return font_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_font_name(::std::string* font_name) {
  if (font_name != NULL) {
    set_has_font_name();
  } else {
    clear_has_font_name();
  }
  font_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), font_name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.font_name)
}

// optional int32 size = 4;
inline bool Font::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Font::set_has_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Font::clear_has_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Font::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Font::size() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.size)
  return size_;
}
inline void Font::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.size)
}

// optional bool bold = 5;
inline bool Font::has_bold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Font::set_has_bold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Font::clear_has_bold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Font::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool Font::bold() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.bold)
  return bold_;
}
inline void Font::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.bold)
}

// optional bool italic = 6;
inline bool Font::has_italic() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Font::set_has_italic() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Font::clear_has_italic() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Font::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool Font::italic() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.italic)
  return italic_;
}
inline void Font::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.italic)
}

// repeated .buffers.resources.Font.Range ranges = 7 [(.buffers.gmx) = "ranges/range0"];
inline int Font::ranges_size() const {
  return ranges_.size();
}
inline void Font::clear_ranges() {
  ranges_.Clear();
}
inline const ::buffers::resources::Font_Range& Font::ranges(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.ranges)
  return ranges_.Get(index);
}
inline ::buffers::resources::Font_Range* Font::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.ranges)
  return ranges_.Mutable(index);
}
inline ::buffers::resources::Font_Range* Font::add_ranges() {
  // @@protoc_insertion_point(field_add:buffers.resources.Font.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >*
Font::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.Font.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >&
Font::ranges() const {
  // @@protoc_insertion_point(field_list:buffers.resources.Font.ranges)
  return ranges_;
}

// repeated .buffers.resources.Font.Glyph glyphs = 8 [(.buffers.gmx) = "glyphs/glyph"];
inline int Font::glyphs_size() const {
  return glyphs_.size();
}
inline void Font::clear_glyphs() {
  glyphs_.Clear();
}
inline const ::buffers::resources::Font_Glyph& Font::glyphs(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.glyphs)
  return glyphs_.Get(index);
}
inline ::buffers::resources::Font_Glyph* Font::mutable_glyphs(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.glyphs)
  return glyphs_.Mutable(index);
}
inline ::buffers::resources::Font_Glyph* Font::add_glyphs() {
  // @@protoc_insertion_point(field_add:buffers.resources.Font.glyphs)
  return glyphs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >*
Font::mutable_glyphs() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.Font.glyphs)
  return &glyphs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >&
Font::glyphs() const {
  // @@protoc_insertion_point(field_list:buffers.resources.Font.glyphs)
  return glyphs_;
}

// optional bool renderhq = 10;
inline bool Font::has_renderhq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Font::set_has_renderhq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Font::clear_has_renderhq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Font::clear_renderhq() {
  renderhq_ = false;
  clear_has_renderhq();
}
inline bool Font::renderhq() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.renderhq)
  return renderhq_;
}
inline void Font::set_renderhq(bool value) {
  set_has_renderhq();
  renderhq_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.renderhq)
}

// optional uint32 charset = 11;
inline bool Font::has_charset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Font::set_has_charset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Font::clear_has_charset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Font::clear_charset() {
  charset_ = 0u;
  clear_has_charset();
}
inline ::google::protobuf::uint32 Font::charset() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.charset)
  return charset_;
}
inline void Font::set_charset(::google::protobuf::uint32 value) {
  set_has_charset();
  charset_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.charset)
}

// optional uint32 aa = 12;
inline bool Font::has_aa() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Font::set_has_aa() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Font::clear_has_aa() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Font::clear_aa() {
  aa_ = 0u;
  clear_has_aa();
}
inline ::google::protobuf::uint32 Font::aa() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.aa)
  return aa_;
}
inline void Font::set_aa(::google::protobuf::uint32 value) {
  set_has_aa();
  aa_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.aa)
}

// optional bool include_ttf = 13 [(.buffers.gmx) = "includeTTF"];
inline bool Font::has_include_ttf() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Font::set_has_include_ttf() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Font::clear_has_include_ttf() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Font::clear_include_ttf() {
  include_ttf_ = false;
  clear_has_include_ttf();
}
inline bool Font::include_ttf() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.include_ttf)
  return include_ttf_;
}
inline void Font::set_include_ttf(bool value) {
  set_has_include_ttf();
  include_ttf_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.include_ttf)
}

// optional string ttf_file = 14 [(.buffers.gmx) = "TTFName"];
inline bool Font::has_ttf_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Font::set_has_ttf_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Font::clear_has_ttf_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Font::clear_ttf_file() {
  ttf_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ttf_file();
}
inline const ::std::string& Font::ttf_file() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.ttf_file)
  return ttf_file_.GetNoArena();
}
inline void Font::set_ttf_file(const ::std::string& value) {
  set_has_ttf_file();
  ttf_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.ttf_file)
}
#if LANG_CXX11
inline void Font::set_ttf_file(::std::string&& value) {
  set_has_ttf_file();
  ttf_file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.ttf_file)
}
#endif
inline void Font::set_ttf_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ttf_file();
  ttf_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.ttf_file)
}
inline void Font::set_ttf_file(const char* value, size_t size) {
  set_has_ttf_file();
  ttf_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.ttf_file)
}
inline ::std::string* Font::mutable_ttf_file() {
  set_has_ttf_file();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.ttf_file)
  return ttf_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_ttf_file() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.ttf_file)
  clear_has_ttf_file();
  return ttf_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_ttf_file(::std::string* ttf_file) {
  if (ttf_file != NULL) {
    set_has_ttf_file();
  } else {
    clear_has_ttf_file();
  }
  ttf_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ttf_file);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.ttf_file)
}

// optional int32 texture_group = 15 [(.buffers.gmx) = "texgroups/texgroup0"];
inline bool Font::has_texture_group() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Font::set_has_texture_group() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Font::clear_has_texture_group() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Font::clear_texture_group() {
  texture_group_ = 0;
  clear_has_texture_group();
}
inline ::google::protobuf::int32 Font::texture_group() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.texture_group)
  return texture_group_;
}
inline void Font::set_texture_group(::google::protobuf::int32 value) {
  set_has_texture_group();
  texture_group_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.texture_group)
}

// optional string image = 16;
inline bool Font::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Font::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Font::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Font::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
inline const ::std::string& Font::image() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.image)
  return image_.GetNoArena();
}
inline void Font::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.image)
}
#if LANG_CXX11
inline void Font::set_image(::std::string&& value) {
  set_has_image();
  image_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.image)
}
#endif
inline void Font::set_image(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.image)
}
inline void Font::set_image(const char* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.image)
}
inline ::std::string* Font::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_image() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.image)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace resources
}  // namespace buffers

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_resources_2fFont_2eproto__INCLUDED
