// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: resources/Font.proto

#ifndef PROTOBUF_resources_2fFont_2eproto__INCLUDED
#define PROTOBUF_resources_2fFont_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "options.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_resources_2fFont_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsFont_GlyphImpl();
void InitDefaultsFont_Glyph();
void InitDefaultsFont_RangeImpl();
void InitDefaultsFont_Range();
void InitDefaultsFontImpl();
void InitDefaultsFont();
inline void InitDefaults() {
  InitDefaultsFont_Glyph();
  InitDefaultsFont_Range();
  InitDefaultsFont();
}
}  // namespace protobuf_resources_2fFont_2eproto
namespace buffers {
namespace resources {
class Font;
class FontDefaultTypeInternal;
extern FontDefaultTypeInternal _Font_default_instance_;
class Font_Glyph;
class Font_GlyphDefaultTypeInternal;
extern Font_GlyphDefaultTypeInternal _Font_Glyph_default_instance_;
class Font_Range;
class Font_RangeDefaultTypeInternal;
extern Font_RangeDefaultTypeInternal _Font_Range_default_instance_;
}  // namespace resources
}  // namespace buffers
namespace buffers {
namespace resources {

// ===================================================================

class Font_Glyph : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font.Glyph) */ {
 public:
  Font_Glyph();
  virtual ~Font_Glyph();

  Font_Glyph(const Font_Glyph& from);

  inline Font_Glyph& operator=(const Font_Glyph& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font_Glyph(Font_Glyph&& from) noexcept
    : Font_Glyph() {
    *this = ::std::move(from);
  }

  inline Font_Glyph& operator=(Font_Glyph&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font_Glyph& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Font_Glyph* internal_default_instance() {
    return reinterpret_cast<const Font_Glyph*>(
               &_Font_Glyph_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Font_Glyph* other);
  friend void swap(Font_Glyph& a, Font_Glyph& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font_Glyph* New() const PROTOBUF_FINAL { return New(NULL); }

  Font_Glyph* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font_Glyph& from);
  void MergeFrom(const Font_Glyph& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font_Glyph* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes data = 6;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // optional double origin = 1;
  bool has_origin() const;
  void clear_origin();
  static const int kOriginFieldNumber = 1;
  double origin() const;
  void set_origin(double value);

  // optional double baseline = 2;
  bool has_baseline() const;
  void clear_baseline();
  static const int kBaselineFieldNumber = 2;
  double baseline() const;
  void set_baseline(double value);

  // optional double advance = 3;
  bool has_advance() const;
  void clear_advance();
  static const int kAdvanceFieldNumber = 3;
  double advance() const;
  void set_advance(double value);

  // optional int32 width = 4;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 4;
  ::google::protobuf::int32 width() const;
  void set_width(::google::protobuf::int32 value);

  // optional int32 height = 5;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 5;
  ::google::protobuf::int32 height() const;
  void set_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font.Glyph)
 private:
  void set_has_origin();
  void clear_has_origin();
  void set_has_baseline();
  void clear_has_baseline();
  void set_has_advance();
  void clear_has_advance();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  double origin_;
  double baseline_;
  double advance_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  friend struct ::protobuf_resources_2fFont_2eproto::TableStruct;
  friend void ::protobuf_resources_2fFont_2eproto::InitDefaultsFont_GlyphImpl();
};
// -------------------------------------------------------------------

class Font_Range : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font.Range) */ {
 public:
  Font_Range();
  virtual ~Font_Range();

  Font_Range(const Font_Range& from);

  inline Font_Range& operator=(const Font_Range& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font_Range(Font_Range&& from) noexcept
    : Font_Range() {
    *this = ::std::move(from);
  }

  inline Font_Range& operator=(Font_Range&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font_Range& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Font_Range* internal_default_instance() {
    return reinterpret_cast<const Font_Range*>(
               &_Font_Range_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Font_Range* other);
  friend void swap(Font_Range& a, Font_Range& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font_Range* New() const PROTOBUF_FINAL { return New(NULL); }

  Font_Range* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font_Range& from);
  void MergeFrom(const Font_Range& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font_Range* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .buffers.resources.Font.Glyph glyphs = 3;
  int glyphs_size() const;
  void clear_glyphs();
  static const int kGlyphsFieldNumber = 3;
  const ::buffers::resources::Font_Glyph& glyphs(int index) const;
  ::buffers::resources::Font_Glyph* mutable_glyphs(int index);
  ::buffers::resources::Font_Glyph* add_glyphs();
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >*
      mutable_glyphs();
  const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >&
      glyphs() const;

  // optional int32 min = 1;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 1;
  ::google::protobuf::int32 min() const;
  void set_min(::google::protobuf::int32 value);

  // optional int32 max = 2;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  ::google::protobuf::int32 max() const;
  void set_max(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font.Range)
 private:
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph > glyphs_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int32 max_;
  friend struct ::protobuf_resources_2fFont_2eproto::TableStruct;
  friend void ::protobuf_resources_2fFont_2eproto::InitDefaultsFont_RangeImpl();
};
// -------------------------------------------------------------------

class Font : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:buffers.resources.Font) */ {
 public:
  Font();
  virtual ~Font();

  Font(const Font& from);

  inline Font& operator=(const Font& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Font(Font&& from) noexcept
    : Font() {
    *this = ::std::move(from);
  }

  inline Font& operator=(Font&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Font& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Font* internal_default_instance() {
    return reinterpret_cast<const Font*>(
               &_Font_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Font* other);
  friend void swap(Font& a, Font& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Font* New() const PROTOBUF_FINAL { return New(NULL); }

  Font* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Font& from);
  void MergeFrom(const Font& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Font* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Font_Glyph Glyph;
  typedef Font_Range Range;

  // accessors -------------------------------------------------------

  // repeated .buffers.resources.Font.Range ranges = 7;
  int ranges_size() const;
  void clear_ranges();
  static const int kRangesFieldNumber = 7;
  const ::buffers::resources::Font_Range& ranges(int index) const;
  ::buffers::resources::Font_Range* mutable_ranges(int index);
  ::buffers::resources::Font_Range* add_ranges();
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >*
      mutable_ranges();
  const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >&
      ranges() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string font_name = 3 [(.buffers.gmx) = "name"];
  bool has_font_name() const;
  void clear_font_name();
  static const int kFontNameFieldNumber = 3;
  const ::std::string& font_name() const;
  void set_font_name(const ::std::string& value);
  #if LANG_CXX11
  void set_font_name(::std::string&& value);
  #endif
  void set_font_name(const char* value);
  void set_font_name(const char* value, size_t size);
  ::std::string* mutable_font_name();
  ::std::string* release_font_name();
  void set_allocated_font_name(::std::string* font_name);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 size = 4;
  bool has_size() const;
  void clear_size();
  static const int kSizeFieldNumber = 4;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // optional bool bold = 5;
  bool has_bold() const;
  void clear_bold();
  static const int kBoldFieldNumber = 5;
  bool bold() const;
  void set_bold(bool value);

  // optional bool italic = 6;
  bool has_italic() const;
  void clear_italic();
  static const int kItalicFieldNumber = 6;
  bool italic() const;
  void set_italic(bool value);

  // @@protoc_insertion_point(class_scope:buffers.resources.Font)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_id();
  void clear_has_id();
  void set_has_font_name();
  void clear_has_font_name();
  void set_has_size();
  void clear_has_size();
  void set_has_bold();
  void clear_has_bold();
  void set_has_italic();
  void clear_has_italic();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range > ranges_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr font_name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 size_;
  bool bold_;
  bool italic_;
  friend struct ::protobuf_resources_2fFont_2eproto::TableStruct;
  friend void ::protobuf_resources_2fFont_2eproto::InitDefaultsFontImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Font_Glyph

// optional double origin = 1;
inline bool Font_Glyph::has_origin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font_Glyph::set_has_origin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font_Glyph::clear_has_origin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font_Glyph::clear_origin() {
  origin_ = 0;
  clear_has_origin();
}
inline double Font_Glyph::origin() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.origin)
  return origin_;
}
inline void Font_Glyph::set_origin(double value) {
  set_has_origin();
  origin_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.origin)
}

// optional double baseline = 2;
inline bool Font_Glyph::has_baseline() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Font_Glyph::set_has_baseline() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Font_Glyph::clear_has_baseline() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Font_Glyph::clear_baseline() {
  baseline_ = 0;
  clear_has_baseline();
}
inline double Font_Glyph::baseline() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.baseline)
  return baseline_;
}
inline void Font_Glyph::set_baseline(double value) {
  set_has_baseline();
  baseline_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.baseline)
}

// optional double advance = 3;
inline bool Font_Glyph::has_advance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Font_Glyph::set_has_advance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Font_Glyph::clear_has_advance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Font_Glyph::clear_advance() {
  advance_ = 0;
  clear_has_advance();
}
inline double Font_Glyph::advance() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.advance)
  return advance_;
}
inline void Font_Glyph::set_advance(double value) {
  set_has_advance();
  advance_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.advance)
}

// optional int32 width = 4;
inline bool Font_Glyph::has_width() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Font_Glyph::set_has_width() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Font_Glyph::clear_has_width() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Font_Glyph::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Font_Glyph::width() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.width)
  return width_;
}
inline void Font_Glyph::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.width)
}

// optional int32 height = 5;
inline bool Font_Glyph::has_height() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Font_Glyph::set_has_height() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Font_Glyph::clear_has_height() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Font_Glyph::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Font_Glyph::height() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.height)
  return height_;
}
inline void Font_Glyph::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.height)
}

// optional bytes data = 6;
inline bool Font_Glyph::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font_Glyph::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font_Glyph::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font_Glyph::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& Font_Glyph::data() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Glyph.data)
  return data_.GetNoArena();
}
inline void Font_Glyph::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Glyph.data)
}
#if LANG_CXX11
inline void Font_Glyph::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.Glyph.data)
}
#endif
inline void Font_Glyph::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.Glyph.data)
}
inline void Font_Glyph::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.Glyph.data)
}
inline ::std::string* Font_Glyph::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.Glyph.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font_Glyph::release_data() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.Glyph.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font_Glyph::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.Glyph.data)
}

// -------------------------------------------------------------------

// Font_Range

// optional int32 min = 1;
inline bool Font_Range::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font_Range::set_has_min() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font_Range::clear_has_min() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font_Range::clear_min() {
  min_ = 0;
  clear_has_min();
}
inline ::google::protobuf::int32 Font_Range::min() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Range.min)
  return min_;
}
inline void Font_Range::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Range.min)
}

// optional int32 max = 2;
inline bool Font_Range::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font_Range::set_has_max() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font_Range::clear_has_max() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font_Range::clear_max() {
  max_ = 0;
  clear_has_max();
}
inline ::google::protobuf::int32 Font_Range::max() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Range.max)
  return max_;
}
inline void Font_Range::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.Range.max)
}

// repeated .buffers.resources.Font.Glyph glyphs = 3;
inline int Font_Range::glyphs_size() const {
  return glyphs_.size();
}
inline void Font_Range::clear_glyphs() {
  glyphs_.Clear();
}
inline const ::buffers::resources::Font_Glyph& Font_Range::glyphs(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.Range.glyphs)
  return glyphs_.Get(index);
}
inline ::buffers::resources::Font_Glyph* Font_Range::mutable_glyphs(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.Range.glyphs)
  return glyphs_.Mutable(index);
}
inline ::buffers::resources::Font_Glyph* Font_Range::add_glyphs() {
  // @@protoc_insertion_point(field_add:buffers.resources.Font.Range.glyphs)
  return glyphs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >*
Font_Range::mutable_glyphs() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.Font.Range.glyphs)
  return &glyphs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Glyph >&
Font_Range::glyphs() const {
  // @@protoc_insertion_point(field_list:buffers.resources.Font.Range.glyphs)
  return glyphs_;
}

// -------------------------------------------------------------------

// Font

// optional string name = 1;
inline bool Font::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Font::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Font::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Font::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Font::name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.name)
  return name_.GetNoArena();
}
inline void Font::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.name)
}
#if LANG_CXX11
inline void Font::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.name)
}
#endif
inline void Font::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.name)
}
inline void Font::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.name)
}
inline ::std::string* Font::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.name)
}

// optional int32 id = 2;
inline bool Font::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Font::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Font::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Font::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Font::id() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.id)
  return id_;
}
inline void Font::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.id)
}

// optional string font_name = 3 [(.buffers.gmx) = "name"];
inline bool Font::has_font_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Font::set_has_font_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Font::clear_has_font_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Font::clear_font_name() {
  font_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_font_name();
}
inline const ::std::string& Font::font_name() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.font_name)
  return font_name_.GetNoArena();
}
inline void Font::set_font_name(const ::std::string& value) {
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:buffers.resources.Font.font_name)
}
#if LANG_CXX11
inline void Font::set_font_name(::std::string&& value) {
  set_has_font_name();
  font_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:buffers.resources.Font.font_name)
}
#endif
inline void Font::set_font_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:buffers.resources.Font.font_name)
}
inline void Font::set_font_name(const char* value, size_t size) {
  set_has_font_name();
  font_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:buffers.resources.Font.font_name)
}
inline ::std::string* Font::mutable_font_name() {
  set_has_font_name();
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.font_name)
  return font_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Font::release_font_name() {
  // @@protoc_insertion_point(field_release:buffers.resources.Font.font_name)
  clear_has_font_name();
  return font_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Font::set_allocated_font_name(::std::string* font_name) {
  if (font_name != NULL) {
    set_has_font_name();
  } else {
    clear_has_font_name();
  }
  font_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), font_name);
  // @@protoc_insertion_point(field_set_allocated:buffers.resources.Font.font_name)
}

// optional int32 size = 4;
inline bool Font::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Font::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Font::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Font::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline ::google::protobuf::int32 Font::size() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.size)
  return size_;
}
inline void Font::set_size(::google::protobuf::int32 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.size)
}

// optional bool bold = 5;
inline bool Font::has_bold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Font::set_has_bold() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Font::clear_has_bold() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Font::clear_bold() {
  bold_ = false;
  clear_has_bold();
}
inline bool Font::bold() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.bold)
  return bold_;
}
inline void Font::set_bold(bool value) {
  set_has_bold();
  bold_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.bold)
}

// optional bool italic = 6;
inline bool Font::has_italic() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Font::set_has_italic() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Font::clear_has_italic() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Font::clear_italic() {
  italic_ = false;
  clear_has_italic();
}
inline bool Font::italic() const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.italic)
  return italic_;
}
inline void Font::set_italic(bool value) {
  set_has_italic();
  italic_ = value;
  // @@protoc_insertion_point(field_set:buffers.resources.Font.italic)
}

// repeated .buffers.resources.Font.Range ranges = 7;
inline int Font::ranges_size() const {
  return ranges_.size();
}
inline void Font::clear_ranges() {
  ranges_.Clear();
}
inline const ::buffers::resources::Font_Range& Font::ranges(int index) const {
  // @@protoc_insertion_point(field_get:buffers.resources.Font.ranges)
  return ranges_.Get(index);
}
inline ::buffers::resources::Font_Range* Font::mutable_ranges(int index) {
  // @@protoc_insertion_point(field_mutable:buffers.resources.Font.ranges)
  return ranges_.Mutable(index);
}
inline ::buffers::resources::Font_Range* Font::add_ranges() {
  // @@protoc_insertion_point(field_add:buffers.resources.Font.ranges)
  return ranges_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >*
Font::mutable_ranges() {
  // @@protoc_insertion_point(field_mutable_list:buffers.resources.Font.ranges)
  return &ranges_;
}
inline const ::google::protobuf::RepeatedPtrField< ::buffers::resources::Font_Range >&
Font::ranges() const {
  // @@protoc_insertion_point(field_list:buffers.resources.Font.ranges)
  return ranges_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace resources
}  // namespace buffers

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_resources_2fFont_2eproto__INCLUDED
